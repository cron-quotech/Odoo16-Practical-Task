# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from datetime import timedelta
from odoo.tools import float_compare
from odoo import _, api, fields, models
from odoo.exceptions import ValidationError


class SaleOrder(models.Model):
    _inherit = "sale.order"

    split_delivery = fields.Boolean("Split Delivery")
    delivery_date = fields.Date(string="Delivery Date")

    def action_confirm(self):
        """
        used default func() to check date validation and add planned date in Sale order line.  
        """
        for order in self:
            if order.split_delivery:
                if not order.delivery_date:
                    raise ValidationError(_('Please assign Delivery Date.'))
                if order.order_line:
                    lines = order.order_line.filtered(lambda l: not l.planned_date)
                    if lines:
                        lines.write({'planned_date': order.delivery_date})
        res = super(SaleOrder, self).action_confirm()
        return res


class SaleOrderLine(models.Model):
    _inherit = "sale.order.line"

    planned_date = fields.Date(string="Planned Date")

    def _action_launch_stock_rule(self, previous_product_uom_qty=False):
        """
        Launch procurement group run method with required/custom fields generated by a
        sale order line. procurement group will launch '_run_pull', '_run_buy' or '_run_manufacture'
        depending on the sale order line product rule.

        used default func() to manage procurement group and based on created DO
        """
        ###cust
        split_delivery = False
        if any(line.order_id.split_delivery for line in self):
        	split_delivery = True
        if split_delivery:
        	self = self.sorted('planned_date')
        	planned_date_lst = []
        ###fcust
        if self._context.get("skip_procurement"):
            return True
        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
        procurements = []

        for line in self:
            line = line.with_company(line.company_id)
            if line.state != 'sale' or not line.product_id.type in ('consu', 'product'):
                continue
            qty = line._get_qty_procurement(previous_product_uom_qty)
            if float_compare(qty, line.product_uom_qty, precision_digits=precision) == 0:
                continue
            if split_delivery:#cust
                if line.planned_date not in planned_date_lst:
                    planned_date_lst.append(line.planned_date)
                    if line.product_uom_qty != qty:#manage qty existing line update
                        picking_rec = line.order_id.picking_ids.filtered( lambda p: p.state not in ['done', 'cancel'] and p.scheduled_date.date() == line.planned_date)
                        if picking_rec:
                            group_id = picking_rec.group_id
                        else:
                            group_id = False
                    else:
                        group_id = False
                else:
                    group_id = line._get_procurement_group()
            else:#def
                group_id = line._get_procurement_group()
            if not group_id:
                group_id = self.env['procurement.group'].create(line._prepare_procurement_group_vals())
                line.order_id.procurement_group_id = group_id
            else:
                # In case the procurement group is already created and the order was
                # cancelled, we need to update certain values of the group.
                updated_vals = {}
                if group_id.partner_id != line.order_id.partner_shipping_id:
                    updated_vals.update({'partner_id': line.order_id.partner_shipping_id.id})
                if group_id.move_type != line.order_id.picking_policy:
                    updated_vals.update({'move_type': line.order_id.picking_policy})
                if updated_vals:
                    group_id.write(updated_vals)

            values = line._prepare_procurement_values(group_id=group_id)
            product_qty = line.product_uom_qty - qty

            line_uom = line.product_uom
            quant_uom = line.product_id.uom_id
            product_qty, procurement_uom = line_uom._adjust_uom_quantities(product_qty, quant_uom)
            procurements.append(self.env['procurement.group'].Procurement(
                line.product_id, product_qty, procurement_uom,
                line.order_id.partner_shipping_id.property_stock_customer,
                line.product_id.display_name, line.order_id.name, line.order_id.company_id, values))
        if procurements:
            procurement_group = self.env['procurement.group']
            if self.env.context.get('import_file'):
                procurement_group = procurement_group.with_context(import_file=False)
            procurement_group.run(procurements)

        # This next block is currently needed only because the scheduler trigger is done by picking confirmation rather than stock.move confirmation
        orders = self.mapped('order_id')
        for order in orders:
            pickings_to_confirm = order.picking_ids.filtered(lambda p: p.state not in ['cancel', 'done'])
            if pickings_to_confirm:
                # Trigger the Scheduler for Pickings
                pickings_to_confirm.action_confirm()
        return True

    def _prepare_procurement_values(self, group_id=False):
        """ 
        used default func() to set planned date as picking date(schedule date of DO) based on condition
        """
        values = super(SaleOrderLine, self)._prepare_procurement_values(group_id)
        if self.order_id.split_delivery:
            values['date_planned'] = self.planned_date
        return values
